## Preamble

```
CAP: 0007
Title: Deterministic Account Creation
Author: Jeremy Rubin
Status: Draft
Created: 2018-11-07
Discussion: https://github.com/stellar/stellar-protocol/issues/99
Protocol version: TBD
```

## Simple Summary
We introduce CreateDeterministicAccount operation which creates an account that
could only be created by the transaction creating it, allowing it to have a
known starting sequence number and initialization.

## Abstract


Deterministic accounts are a critical infrastructure piece for building reliable contracts for three key reasons:

1) Predictable sequence numbers
2) Never-fail creation
3) Known initialized state

We can create deterministic accounts with minimal changes to Stellar by using Key Tweaking to derive the account key.


## Motivation

Currently, when a contract must create an account as a part of it's settlement (such as in Starlight or in an Account Transfer),
creating the account results in an unpredictable sequence number which prevents the presigning of transactions for it. Furthermore,
accounts can not be created and modified at the same time preventing initializing an account on behalf of another party.


## Specification

We assume a function `PublicKey derive(PublicKey pk, const *char buf, size_t
buflen)` as specified by [ChainKD Non Hardened Extended Public
Key](https://chain.com/docs/1.2/protocol/specifications/chainkd#derive-non-hardened-extended-public-key) which returns
keys of type `PUBLIC_KEY_TYPE_ED25519_DET`.

We extend the Key types:

```c++

enum CryptoKeyType
{
    KEY_TYPE_ED25519 = 0,
    KEY_TYPE_PRE_AUTH_TX = 1,
    KEY_TYPE_HASH_X = 2
    KEY_TYPE_ED25519_DET = 3
};

enum PublicKeyType
{
    PUBLIC_KEY_TYPE_ED25519 = KEY_TYPE_ED25519,
    PUBLIC_KEY_TYPE_ED25519_DET = KEY_TYPE_ED25519_DET,
};


union PublicKey switch (PublicKeyType type)
{
case PUBLIC_KEY_TYPE_ED25519:
    uint256 ed25519;
case PUBLIC_KEY_TYPE_ED25519_DET:
	uint256 ed25519;
};


```



We add the following operation:
```c++
struct CreateDeterministicAccountOp
{
    PublicKey keyToDeriveFrom;
    int64 startingBalance;
    *Signer first_signer;
	uint32 masterWeight;

};
```

The result of this operation is an account created with the following state:
```c++
AccountEntry
{
    accountID = derive(op.keyToDeriveFrom, SHA512()
										.hash(tx.hash)
										.hash(op.index)
										.digest() ,64),
    balance = op.startingBalance,
    seqNum = 0,
    signers = first_signer ? {first_signer} : {},
	masterWeight = op.masterWeight,
	
}
```




## Rationale

CreateDeterministicAccount is a minimal deterministic account derivation scheme.

The newly created account is deterministically derived from

	- The transaction creating it, which transitively commits to:
		- The Source Account
		- The Source Account Sequence
	- The index of the operation in the transaction (making a unique key if repeated CreateDeterministicAccount operations)


If a more complex setup and initialization of the account is required, then the
first\_signer should be added as a preauth transaction of sufficient weight at
sequence 0, masterWeight should be set to 0. The preauth transaction is then
the only subsequent action that may occur, so care should be taken to ensure
that it must succeed to a redeemable state. A typical use case would be to call
ChangeTrust to attempt to add a trustline (it may fail if the asset issue cannot be found).

Thus, it could be done as follows:

```
Tx0:
	Add signer H(Tx1)
	Add signer H(Tx2)
Tx1:
	Change Trust ExampleBucks(TM) 1000
	Remove H(Tx2)
	SetOptions masterWeight = 1
Tx2: SetOptions masterWeight = 1
```

If the account should be recoverable if the trustline fails to be created.

Protocols around using CreateDeterministicAccount will be the subject of a
subsequent SEP.


## Backwards Compatibility
This proposal requires updating existing APIs to accept the new key type.


## Implementation
No implementation yet.
