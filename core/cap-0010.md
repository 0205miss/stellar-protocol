## Preamble

```
CAP: 0010
Title: Fee Bump Account
Author: Jeremy Rubin
Status: Draft
Created: 2018-11-13
Discussion: None
Protocol version: TBD
```

## Simple Summary

Transactions get stuck because of insufficient fee sometimes, especially if the
protocol changes! 

We partially address this with fee-bumping account.

## Abstract

Transactions get stuck either because of insufficient fees being paid or because
min fees increase.

CAP-10 specifies a 16 bit fee-only account (denominated in basefees) which can
be used to bump only the next transaction from the account.
## Motivation

In protocols which transactions are presigned or preauth for long durations,
it's a major headache if they can't get in because of fee insuficiency. CAP-05
helps with this issue a bit, but doesn't fully address the issue for when things
are truly stuck because they are now invalid.


## Specification


We extend the Account with a `fee_balance` account. `fee_balance` is a receive
only account.
```c++
struct AccountEntry
{
	// ... truncated
    // reserved for future use
    union switch (int v)
    {
    case 0:
        void;
    case 1:
        struct
        {
            Liabilities liabilities;

            union switch (int v)
            {
            case 0:
                void;
			case 1:
				struct
				{
					uint16 fee_balance;
					union switch (int v)
					{
						case 0:
							void;
					} ext;

				} v2;
            }
            ext;
        } v1;
    }
    ext;
};
```

When a transaction executes for a given source account, it pays an additional
fee of `((int64_t) fee_balance) * base_fee` and clears the `fee_balance`. These
fees are burned and are not inserted into the the Fee Pool. Transactions should not
be rejected for insufficient fee before querying to see if a fee_balance exists and
might cover the transaction.


When the base fee is increased or decreased the fee balance accounts are just
automatically bumped up or down.

On merge, the fees are destroyed.

We also introduce a new operation to add funds to a `fee_balance` account.

```c++
enum OperationType
{
    CREATE_ACCOUNT = 0,
    PAYMENT = 1,
    PATH_PAYMENT = 2,
    MANAGE_OFFER = 3,
    CREATE_PASSIVE_OFFER = 4,
    SET_OPTIONS = 5,
    CHANGE_TRUST = 6,
    ALLOW_TRUST = 7,
    ACCOUNT_MERGE = 8,
    INFLATION = 9,
    MANAGE_DATA = 10,
    BUMP_SEQUENCE = 11,
	BUMP_FEE = 12
};

struct BumpFeeOp
{
    AccountID recipient;
    SequenceNumber unless_passed;
    int64 amount;
};


enum BumpFeeResultCode
{
    // codes considered as "success" for the operation
    BUMP_FEE_SUCCESS = 0,
	BUMP_FEE_INSUFFICIENT_BALANCE = 1,
};

union BumpSequenceResult switch (BumpSequenceResultCode code)
{
case BUMP_FEE_SUCCESS:
    void;
default:
    void;
};


union OperationResult switch (OperationResultCode code)
{
case opINNER:
    union switch (OperationType type)
    {
    case CREATE_ACCOUNT:
        CreateAccountResult createAccountResult;
    case PAYMENT:
        PaymentResult paymentResult;
    case PATH_PAYMENT:
        PathPaymentResult pathPaymentResult;
    case MANAGE_OFFER:
        ManageOfferResult manageOfferResult;
    case CREATE_PASSIVE_OFFER:
        ManageOfferResult createPassiveOfferResult;
    case SET_OPTIONS:
        SetOptionsResult setOptionsResult;
    case CHANGE_TRUST:
        ChangeTrustResult changeTrustResult;
    case ALLOW_TRUST:
        AllowTrustResult allowTrustResult;
    case ACCOUNT_MERGE:
        AccountMergeResult accountMergeResult;
    case INFLATION:
        InflationResult inflationResult;
    case MANAGE_DATA:
        ManageDataResult manageDataResult;
    case BUMP_SEQUENCE:
        BumpSequenceResult bumpSeqResult;
    case BUMP_FEE:
        BumpFeeResult bumpFeeResult;
    }
    tr;
default:
    void;
};

```

The semantics of which are as follows:

If the account does not exist, nothing happens.

If the account sequence number is greater than `unless_passed`, nothing happens.

The appropriate amount of fee is added such that fee_balance does not overflow
and amount is a multiple of `base_fee`, i.e.:

Set `amount = max((2**16 -1)*base_fee, amount).

If there is at least `amount` in the account balance, `amt = max(fee_balance +
(amount / min(1,base_fee)), ~0) - fee_balance`

Then `balance -= amt * base_fee`, `fee_balance += amt`.




## Rationale

It's expensive to add new entries to accounts, so we only add 16 bits. Because
fees should be a multiple of base fee, we only store a multiplier.

We auto-adjust it up or down during a fee change to avoid having to ensure
compatibility with the actual amount of fee (alternatively could update all
records on update...). Auto-adjust implies that we can't release to the fee pool
or you could 'mine' these fee accounts for a bigger fee pool after a change.


We always clear the whole thing and don't allow to recover funds from it. 


## Backwards Compatibility

Base fee may not exceed 2**48 after this change.

Transactions which don't pay base fee rate must now query to see if a fee_balance
exists rather than being outright invalid.

Storage wise, it may make sense to store these fee accounts in a separate table
as their should be relatively few of them (they clear after every transaction
made by the account). It could also be set up such that unused fee balances
clear after a few days of ledgers or something automatically. If this design
(with it's extra complexity) is truly advantageous, perhaps they shouldn't be
in the accounts at all, but rather stored in a wholly separate struct from the
accounts (but still use accountID).



## Implementation

None yet.
