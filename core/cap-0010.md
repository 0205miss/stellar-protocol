## Preamble

```
CAP: 0010
Title: Replace by Fee Transactions
Author: OrbitLens <orbit.lens@gmail.com>
Status: Draft
Created: 2018-11-26
Updated: 2018-11-26
Discussion: https://groups.google.com/forum/#!topic/stellar-dev/ckzBRlfr2VU
Protocol version: TBD
```

## Simple Summary

This CAP introduces the concept of replace-by-fee (RBF) transaction to allow 
paying transaction fees by arbitrary account.

## Abstract

There are a few cases that require charging transaction fees from account 
balance other than `source` account:

- Games, exchanges, and other applications willing to pay user fees. 
- Pre-signed transactions in case of the `base_fee` increase.
- Coordinated multi-sig transactions with insufficient fees. 
- Fee optimization services that can ensure transactions execution in fee 
racing conditions.

This CAP introduces RBF transactions by adding `replace_fee_tx` and  
`max_replace_fee` fields to the Transaction XDR. 

## Motivation

The problem of paying fees for another account has been discussed multiple 
times. Current solutions are based on multi-sig with source account replacement 
or direct [fees "refund"](
https://www.lumenauts.com/blog/better-stellar-fee-channels) for user accounts. 
However, both approaches are not ideal and require multi-sig coordination. 
With RBF transactions users can sign and submit transactions to the 
application server endpoint which automatically creates and submits 
corresponding RBF transactions. 

In the case of `base_fee` protocol parameter increase, long-lived preauthorized 
transactions may become invalid because of insufficient fees. Currently, we 
have no mechanism that would allow changing fees for such transactions, or 
"pushing" them to the ledger in any other way. 


## Specification

We extend the Transaction XDR with a `replace_fee_tx` and `max_replace_fee` 
fields, where 

- `replace_fee_tx` represents the hash of the transaction for which fees 
should be replaced.
- `max_replace_fee` specifies the maximum amount that can be charged to the 
RBF `source` account.

```c++
struct Transaction
{
    // ...
    union switch (int v)
    {
    case 0:
        void;
    case 1:
        struct
        { 
            Hash replace_fee_tx;
            int64 max_replace_fee;            
            union switch (int v)
            {
                case 0:
                    void;
            } ext;
        } v1;
    }
};
```

Both transactions (RBF and original) have to be submitted to the Network 
simultaneously and included in the same ledger. 

Whenever the validator receives a RBF transaction, it looks for the original 
transaction by the hash specified in the `replace_fee_tx` field of the RBF 
transaction and adds the `max_replace_fee` amount to the original transaction 
`fee` bid. 

- If the required fee amount is higher than the `fee` of the original 
transaction, the `fee` amount is charged on the original transaction 
`source` account, and any excess is charged against the RBF `source` account.
- If the original transaction has a `fee` set to zero, the entire amount of 
required fees should be charged on the `source` account of RBF transaction.
- If the original transaction `fee` is sufficient, the RBF transaction should 
be discarded with `tx_excessive_fee` message without RBF `source` sequence 
bump. 
- If the original transaction was not found by hash, the RBF transaction should 
fail with message code `tx_original_transaction_not_found`.
- If `original fee + max_replace_fee` is less than required min fee, both 
transactions should fail with message code `tx_insufficient_fee`.

## Rationale

The proposed solution requires minimum protocol changes and covers a wide 
range of potential use-cases leaving a room for the possible future 
modifications. It also resolves the problem of long-lived preauthorized 
transactions. 

RBF transactions follow the standard lifecycle, therefore they preserve all 
smart contract capabilities including sequence checks, multi-sig for the 
source account, and time-locking. 

## Discussion

- Is there any reliable way to send both transactions to Horizon 
simultaneously?  
Maybe we could make use of XdrStream similar to the history archives 
serialization format to send more than one transaction in a single HTTP 
request? 
- Maybe we should completely ignore the `fee` specified in the original  
transaction and charge the whole require fee amount against the RBF `source` 
account? 
- Should we charge `base_fee` for the RBF transaction itself? 
- What if RBF transaction contains any additional operations? 
- How RBF transactions correlate with `max_tx_set_size`? 
- Using RBF transactions may lead to the increase CPU loading for validators. 