
## Preamble

```
SEP: Not assigned
Title: Txrep: Canonical human-readable representation of Stellar transactions
Author: David MaziÃ¨res
Status: Draft
Created: 2018-08-31
```

## Simple Summary

Txrep is a human-readable representation of Stellar transactions.

## Abstract

This document specifies _txrep_, a human-readable format for Stellar
transactions.  Txrep is unambigous and machine-parsable.  Binary XDR
transactions can be decompiled into txrep format and recompiled to the
exact same binary bytes.

## Motivation

Documentation describing how to use Stellar needs to talk concretely
about the contents of transactions.  Without a canonical
human-readable format for transactions, different documents will each
devise their own way of describing transactions, sometimes
ambiguously, making it hard to relate information from multiple
sources.

Furthermore, advanced Stellar users need a way to craft arbitrary
transactions.  This functionality is currently available from the
[Stellar laboratory transaction builder](https://www.stellar.org/laboratory/#txbuilder),
but that is not a good solution for high security, as it requires a
browser (and in practice requires trusting an HTTPS certificate).
Moreover, the transactions one builds in a web browser cannot easily
be audited before signing, or described in documentation, or scripted,
or placed under version control.

Finally, "dumb" contracts may need to specify Stellar transactions
unambiguously.  For example, a legal contract promising to deliver
tokens with a lock-up period in exchange for a wire transfer may want
to specify the exact lock-up mechanism used through a human readable
description of the Stellar transactions involved.  Using txrep, this
description can be unambiguous.

## Specification

A txrep file consists of a number of lines, each describing the value
of a field.  We describe the line format using a simple BNF-like
notation in which brackets ([...]) indicate optional contents, pipe
(|) indicates alternatives, and an asterisk (*) indicates zero or more
repetitions of the previous symbol.  Literal text (namely `:`, `.`,
`[`, `]`, `.present`, and `.len`, and `_`) indicate the occurence of
those specific characters in the txrep source.  Lines then have the
following format:

> _line_ = _field_ `:` SP* _value_ [_comment_] LF
>
> _comment_ = zero or more characters other than LF
>
> SP = space (ASCII 32)
>
> LF = newline (ASCII 10)

The _field_ and _value_ format are described below.

### Fields

A field has the following syntax:

> _field_ = _tag_ _selector_* [_pseudoselector_]
>
> _selector_ = `.` _tag_ | `[` _integer_ `]`
>
> _tag_ = _capital_ _wordchar_*
>
> _pseudoselector_ = `.present` | `.len`
>
> _integer_ = A decimal integer
>
> _capital_ = Any capital letter
>
> _wordchar_ = Any letter, any digit, or `_`

Disregarding _pseudoselector_, each _field_ names a field in an [XDR
`TransactionEnvelope` data
structure](https://github.com/stellar/stellar-core/blob/master/src/xdr/Stellar-transaction.x#L351).
The name is generated by joining XDR field names with a period (`.`),
similar to the syntax used for accessing nested fields in C++ or go
representations of XDR data structures.  However, every field name is
capitalized, regardless of the capitalization of the first character
in the XDR file.  Array elements (for both fixed- and variable-length
arrays) are indexed using square brackets.

As an example, the _field_ `Tx.TimeBounds.MinTime` names the `minTime`
field in the `tx` field of the `TransactionEnvelope` structure, which
looks like this:

~~~~ {.c}
struct TimeBounds {
    uint64 minTime;
    uint64 maxTime; // 0 here means no maxTime
};
struct Transaction {
    /* ... */
    TimeBounds* timeBounds;
    Operation operations<100>;
    /* ... */
};
struct TransactionEnvelope {
    Transaction tx;
    DecoratedSignature signatures<20>;
};
~~~~

Pointers and variable-length arrays use pseudoselectors to describe
their state.  Lines containing pseudoselectors must precede other
selectors of the same field.

Pointers use the `.present` pseudoselector with value `true` or
`false` to indicate that the field is present or NULL, respectively.
For example, a transaction with timebounds might be specified like
this (using comments to annotate the times):

~~~~
Tx.TimeBounds.present: true
Tx.TimeBounds.MinTime: 1535756672 (Fri Aug 31 16:04:32 PDT 2018)
Tx.TimeBounds.MaxTime: 1567292672 (Sat Aug 31 16:04:32 PDT 2019)
~~~~

A transaction without timebounds would contain this line:

~~~~
Tx.TimeBounds.present: false
~~~~

Variable-length arrays use the pseudo-selector `.len` with an integer
value to indicate the number of elements of the variable-length array.
Only indexes from 0 to len-1 are meaningful.  For example, a
transaction with one operation might look like this:

~~~~
Tx.Operations.len: 1
Tx.Operations[0].SourceAccount.present: false
Tx.Operations[0].Body.Type: PAYMENT
...
~~~~

### Values

Most XDR types are rendered intuitively in a C-like syntax.
Specifically:

 * All integers (signed and unsigned, 32- and 64-bit) are represented
   as C integers (decimal by default, but prefix `0x` can be used for
   hex and `0` for octal).

 * `bool` values are `true` or `false`

 * Enums are represented by the capitalized bare keyword of the value
   (most already start with a capital letter anyway).  They cannot be
   specified numerically (but omitting a line for a field is the same
   as specifying 0).

 * `string` values are represented as double-quoted interpreted string
   literals, in which non-ASCII bytes can be represented with hex
   escapes (`"\xff"`), the `"` and `\` characters can be escaped with
   another `\` (e.g., `"\\"`), and `\n` designates a newline.

 * `opaque` values are represented as an unquoted hexadecimal string
   (using lower-case case `a`...`f`)

A few aggregate values are special-cased:

 * The `AssetCode` field in `Assets` is rendered as ASCII bytes (not
   surrounded by double-quotes).  Non-printable characters and
   non-ASCII bytes (including space, to avoid a space being
   interpreted as part of a comment) are hex escaped (`\xff`), while
   backslash is self-escaped (`\\`).

 * `PublicKey` and `SignerKey` are rendered as unquoted strings in
   strkey format, described below.

Any fields in the XDR `TransactionEnvelope` structure that are not
specified in a txrep description are to be interpreted as zero (for
numeric values, enums, and fixed-length `opaque`) and zero-length (for
strings, variable-length arrays, and variable-length `opaque`).

### Strkey format

Strkey provides a compact ASCII format for ED25519 public keys,
ED25519 private keys (also known as seeds), pre-authorized transaction
hashes, and hash-x signers (which provide signing authority upon
revelation of a SHA-256 preimage).  Each of these four types has a
corresponding version byte, which determines the first character of
the strkey encoding:

| Key type | Version byte | First char |
| --------------------- | -- | ---- |
| STRKEY_PUBKEY_ED25519 | 6  | G  |
| STRKEY_SEED_ED25519   | 18 | S  |
| STRKEY_PRE_AUTH_TX    | 19 | T  |
| STRKEY_HASH_X         | 23 | X  |

The following steps transform a binary key into a strkey:

1. Prepend the appropriate version byte to the binary key (so, e.g., a
   32-byte ED25519 public key becomes 33 bytes).

1. Compute a 16-bit CRC16 checksum of the combined version byte and
   binary key (using polynomial x<sup>16</sup> + x<sup>12</sup> +
   x<sup>5</sup> + 1).  Append the two-byte checksum to the version
   byte and binary key (e.g., producing a 35-byte quantity for an
   ED25519 public key).

1. Encode the concatenated Version-byte, Binary-key, and CRC16 using
   [RFC4648 base-32 encoding](https://tools.ietf.org/html/rfc4648#section-6).

## Rationale

This format is human-readable and extensible to future transaction
updates as the XDR files change.  Having each line be self-contained
means that one can excerpt any subset of a transaction with no
ambiguity.  The format is also trivial to parse pragmatically.  Pretty
much every language has functions to read files line-by-line and break
strings at a specific character (to separate field and value at `:`).
Printing field and value is even more trivial.  This means
security-sensitive applications can avoid depending on external
libraries for more complicated formats such as JSON or XLM.

Two special cases (for keys and assets) make the output easier for
humans to process by providing compatibility with other tools.

Field names are capitalized to avoid conflicting with pseudoselectors,
and because ecosystem software written in Go needs to capitalize field
names anyway.

## Test Cases

The following binary transaction:

~~~~
AAAAACsWS5BDhC5BjpKQtznHFJ3CkU6+XtWopW+t+Q9KoH7QAAAAZAClKY0AAAABAAAAAQAAAABbicmAAAAAAF1q/QAAAAABAAAAFkVuam95IHRoaXMgdHJhbnNhY3Rpb24AAAAAAAEAAAAAAAAAAQAAAABAXzbt2M8i77+AcrmFtqTAFVHDTdOME3rI1A1ALNH3tAAAAAFVU0QAAAAAADJSVDIhkp9uz61Ra68rs3ScZIIgjT8ajX8Kkdc1be0LAAAAABfXk6AAAAAAAAAAAUqgftAAAABA3vtPH60cJ5MntVrxhP3N33P096jLQOflNKcdc6BRJLo2nbem0xtHyv0RhZIkaoV15sJJq5TsN2je22KSIhzlDA==
~~~~

Can be rendered like this (note that comments are optional and can
contain implementation-dependent information):

~~~~
Tx.SourceAccount: GAVRMS4QIOCC4QMOSKILOOOHCSO4FEKOXZPNLKFFN6W7SD2KUB7NBPLN
Tx.Fee: 100
Tx.SeqNum: 46489056724385793
Tx.TimeBounds.present: true
Tx.TimeBounds.MinTime: 1535756672 (Fri Aug 31 16:04:32 PDT 2018)
Tx.TimeBounds.MaxTime: 1567292672 (Sat Aug 31 16:04:32 PDT 2019)
Tx.Memo.Type: MEMO_TEXT
Tx.Memo.Text: "Enjoy this transaction"
Tx.Operations.len: 1
Tx.Operations[0].SourceAccount.present: false
Tx.Operations[0].Body.Type: PAYMENT
Tx.Operations[0].Body.PaymentOp.Destination: GBAF6NXN3DHSF357QBZLTBNWUTABKUODJXJYYE32ZDKA2QBM2H33IK6O
Tx.Operations[0].Body.PaymentOp.Asset.Type: ASSET_TYPE_CREDIT_ALPHANUM4
Tx.Operations[0].Body.PaymentOp.Asset.AlphaNum4.AssetCode: USD
Tx.Operations[0].Body.PaymentOp.Asset.AlphaNum4.Issuer: GAZFEVBSEGJJ63WPVVIWXLZLWN2JYZECECGT6GUNP4FJDVZVNXWQWMYI
Tx.Operations[0].Body.PaymentOp.Amount: 400004000 (40.0004e7)
Tx.Ext.V: 0
Signatures.len: 1
Signatures[0].Hint: 4aa07ed0 (GAVRMS4QIOCC4QMOSKILOOOHCSO4FEKOXZPNLKFFN6W7SD2KUB7NBPLN)
Signatures[0].Signature: defb4f1fad1c279327b55af184fdcddf73f4f7a8cb40e7e534a71d73a05124ba369db7a6d31b47cafd118592246a8575e6c249ab94ec3768dedb6292221ce50c
~~~~

## Implementation

Txrep is implemented by the Stellar transaction compiler,
[stc](https://github.com/xdrpp/stc).
